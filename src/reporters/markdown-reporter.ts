/**
 * Markdown Reporter
 * Generates shareable Markdown reports from test results
 */

import Handlebars from 'handlebars';
import { writeFile, mkdir } from 'fs/promises';
import { dirname } from 'path';
import type {
  ReportData,
  StepMetrics,
  ThresholdResult,
  ErrorSummary,
} from '../types/index.js';

/**
 * Default Markdown template
 */
const DEFAULT_TEMPLATE = `# Performance Test Report: {{metadata.testName}}

**Journey:** {{metadata.journeyId}} ({{metadata.journeyName}})
**Environment:** {{metadata.environment}}
**Date:** {{formatDate metadata.startTime}}
**Duration:** {{formatDuration metadata.duration}}

---

## Summary

| Metric | Value |
|--------|-------|
| Total Requests | {{formatNumber summary.totalRequests}} |
| Successful | {{formatNumber summary.successfulRequests}} ({{percentage summary.successfulRequests summary.totalRequests}}%) |
| Failed | {{formatNumber summary.failedRequests}} |
| Error Rate | {{formatPercent summary.errorRate}} |
| Throughput | {{formatNumber summary.throughput}} req/s |

### Virtual Users

| Metric | Count |
|--------|-------|
| Total | {{summary.virtualUsers.total}} |
| Completed | {{summary.virtualUsers.completed}} |
| Failed | {{summary.virtualUsers.failed}} |

---

## Response Time Distribution

| Percentile | Time (ms) |
|------------|-----------|
| Min | {{latency.min}} |
| Mean | {{latency.mean}} |
| Median (p50) | {{latency.median}} |
| p90 | {{latency.p90}} |
| p95 | {{latency.p95}} |
| p99 | {{latency.p99}} |
| Max | {{latency.max}} |

---

## Step-by-Step Performance

| Step | Requests | Success Rate | Mean (ms) | p50 (ms) | p95 (ms) | p99 (ms) |
|------|----------|--------------|-----------|----------|----------|----------|
{{#each stepMetricsArray}}
| {{this.stepName}} | {{this.requestCount}} | {{formatPercent (successRate this)}} | {{this.latency.mean}} | {{this.latency.median}} | {{this.latency.p95}} | {{this.latency.p99}} |
{{/each}}

---

{{#if thresholdResults.length}}
## Threshold Validation

| Metric | Threshold | Actual | Status |
|--------|-----------|--------|--------|
{{#each thresholdResults}}
| {{this.metric}} | {{this.threshold}}{{this.unit}} | {{this.actual}}{{this.unit}} | {{#if this.passed}}✅ Pass{{else}}❌ Fail{{/if}} |
{{/each}}

---
{{/if}}

{{#if profiles.length}}
## Profile Distribution

| Profile | Expected | Actual | Users |
|---------|----------|--------|-------|
{{#each profiles}}
| {{this.profileName}} | {{this.weight}}% | {{formatPercent this.actualPercentage}} | {{this.userCount}} |
{{/each}}

---
{{/if}}

{{#if errors.length}}
## Errors

| Step | Error Type | Message | Count |
|------|------------|---------|-------|
{{#each errors}}
| {{this.stepId}} | {{this.errorType}} | {{truncate this.message 50}} | {{this.count}} |
{{/each}}

---
{{/if}}

## Raw Data

\`\`\`json
{
  "totalRequests": {{summary.totalRequests}},
  "errorRate": {{summary.errorRate}},
  "latency": {
    "p50": {{latency.median}},
    "p95": {{latency.p95}},
    "p99": {{latency.p99}}
  },
  "throughput": {{summary.throughput}}
}
\`\`\`

---

*Generated by Shield Artillery Framework v{{metadata.version}}*
`;

export class MarkdownReporter {
  private template: Handlebars.TemplateDelegate;

  constructor(customTemplate?: string) {
    this.registerHelpers();
    this.template = Handlebars.compile(customTemplate || DEFAULT_TEMPLATE);
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    // Format date
    Handlebars.registerHelper('formatDate', (date: Date | string) => {
      const d = new Date(date);
      return d.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZoneName: 'short',
      });
    });

    // Format duration
    Handlebars.registerHelper('formatDuration', (ms: number) => {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);

      if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
      }
      if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      }
      return `${seconds}s`;
    });

    // Format number with commas
    Handlebars.registerHelper('formatNumber', (num: number) => {
      return num.toLocaleString();
    });

    // Format percentage
    Handlebars.registerHelper('formatPercent', (num: number) => {
      return `${(num * 100).toFixed(2)}%`;
    });

    // Calculate percentage
    Handlebars.registerHelper('percentage', (part: number, total: number) => {
      if (total === 0) return '0.00';
      return ((part / total) * 100).toFixed(2);
    });

    // Calculate success rate
    Handlebars.registerHelper('successRate', (metrics: StepMetrics) => {
      if (metrics.requestCount === 0) return 0;
      return metrics.successCount / metrics.requestCount;
    });

    // Truncate string
    Handlebars.registerHelper('truncate', (str: string, len: number) => {
      if (!str) return '';
      if (str.length <= len) return str;
      return str.substring(0, len) + '...';
    });

    // Conditional if equals
    Handlebars.registerHelper('ifEquals', function (
      this: unknown,
      arg1: unknown,
      arg2: unknown,
      options: Handlebars.HelperOptions
    ) {
      return arg1 === arg2 ? options.fn(this) : options.inverse(this);
    });
  }

  /**
   * Generate Markdown report
   */
  generate(data: ReportData): string {
    // Convert Map to array for iteration
    const stepMetricsArray = Array.from(data.stepMetrics.values());

    const templateData = {
      ...data,
      stepMetricsArray,
    };

    return this.template(templateData);
  }

  /**
   * Generate and save report to file
   */
  async save(data: ReportData, outputPath: string): Promise<void> {
    const markdown = this.generate(data);
    await mkdir(dirname(outputPath), { recursive: true });
    await writeFile(outputPath, markdown, 'utf-8');
  }
}

/**
 * Convenience function to generate Markdown report
 */
export function generateMarkdownReport(data: ReportData): string {
  const reporter = new MarkdownReporter();
  return reporter.generate(data);
}

/**
 * Convenience function to save Markdown report
 */
export async function saveMarkdownReport(
  data: ReportData,
  outputPath: string
): Promise<void> {
  const reporter = new MarkdownReporter();
  await reporter.save(data, outputPath);
}
